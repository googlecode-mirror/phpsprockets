==Towards a better PHP widget library==

_I wrote this back in September 2006 and include it here to try to explain the thought process that went into developing phpSprockets. The code examples here are probably best considered as the prehistoric ancestors of phpSprockets._

As PHP has matured, its role has changed from an inline scripting engine 'helping' HTML, through a templating phase, to being a complete HTML generator. However, just as Captain Kirk was often reduced to fighting aliens with sticks and bright ideas instead of phasers and photon torpedoes, it can sometimes be a real chore to output HTML. It's as if things are made of wood when it comes to flexibly, programatically, generating HTML.

The objective of this article is to introduce a widget set designed to generate hierarchical, standards-compliant HTML in an elegant, maintainable and extendable way.

The most important aspect is being extendable: generating HTML is the first baby step towards a well-designed scaffolding and formbuilding system.

==Anti-objective==

What isn't desired is a the kind of environment that forces its users back into the barbaric world of hand-coding html as soon as a situation arises that was not considered when the library was conceived. Pear tends to do this, and the existing Zend Framework 'helpers' are underpowered for the kind of tasks I have in mind. I'm developing this library to use in the Zend Framework, but it has no dependencies on that fine codebase.
Skeletons along the roadside

As with any project, one of the first questions should be "what are other people doing? It turns out that there are no successful widget libraries for PHP. There are dozens of sort-of 'helper' utilities, but nothing robust and all-encompassing that we can build entire sites with. There are some interesting models in the Yahoo UI library, but nothing that makes me want to use existing code. I'm well aware that many, many developers have their own systems for generating HTML; I've simply chosen to do this in blog form.

==Maintain focus==

We want the tags to render HTML, such as this:
{{{
<div class='box'>
  <h1>Heading</h1>
  <p>This is some text</p>
  <input type='text' name='reply' value='This is a reply' size=30 />
</div>
}}}

Which we can break down as:
{{{
<tagname attributes>content</tagname>
}}}
Where (with a few exceptions) attributes is a number of label='value' pairs content is a number of tags or text.

There's also short 'self-closing' tags:
{{{
<tagname attributes />
}}}

Which can be generated by a devolved subclass of our tag class.

As you can see we'll need a fundamental Text class to describe the content of the tags.Our class structure is going to be like this:
Text -> Tag -> ShortTag

==Tag Objects==

Obviously there is going to be a root class for our tags (and a subclass for self-closing tags such as br and img), and it should be easy to set attributes and hierarchically structure the tags. I like code that looks like this:
{{{
$tag->id = 'an_identifier'; // adds id='an-identifier' to the tag 
$another_tag->add($tag); // put $tag inside $another_tag
}}}

We could override the setter method __set() to maintain an array of attributes so we can sandbox the attributes.
{{{
$a_table = new table();
$a_table->class = 'css_class'; 
$a_row = new tr(); 
$a_table->add($a_row);
}}}

When it comes to add(), we maintain a content array. We could also use func_get_args() to add multiple tags in one line.
{{{
$a_table->add($row_1, $row_2, $row_3);
}}}
But just how many tag classes are we going to need? Is there a pitfall in committing to the obvious model?

==The Programming Model==

Obviously as soon as we start making tags into classes we're going to want convenience methods, especially constructors. For example, when we build an image tag, we're almost always wanting to specify a src, and if the constructor includes a default alt attribute we're closer to producing W3C-compliant code automatically. This could really help when dealing with clients who get obsessed with W3C validation.

The problem with one class for every constructor is that as soon as we start wanting to produce composite tags - checkboxes with labels comes to mind - it muddies the water regarding what a tag is; the tags should represent HTML in a 1:1 way, not in an increasingly byzantine series of classes and files.

If we maintain one class for every tag, we could maintain a nice clean W3C-ish model and hand over composite tags to singleton factories:
{{{
$checkbox = HTML::LabeledCheckbox('input_name', "Check me");
}}}

Which is quite nice, but we can abstract further. It's a shame that PHP 5 doesn't allow the overriding of static 'magic' methods like __call(), as we could make the kernal of a nice html factory in a single method. Instead we would have to write constructors for each tag. An alternative might be to "bring the factory to the tag", like this:
{{{
$HTML = new Tag(); 
$p = $HTML->p("Some text"); 
$div = $HTML->div(); 
$div->add($p);
}}}

So suppose we build a tag class that has the tagname as a variable, and can render any tag, and can consequently add any tag to itself. Also, if we look at code that involves more than one tag - the relationship between tags - then we can see that the main relationship is in adding one tag to another. In fact, this is the only relationship between tags.

To cut a long story short, I'm thinking of combining creating tags with adding tags like this:
{{{
$html = new Tag(); // create context
$table = $html->table(); // add a table to the context 
$row1 = $table->tr(); // add a row to the table 
$row1->th("A header"); // fill out the row 
$row1->td("A data cell"); // etc.
}}}

==Summary==

There are lots of ways of making tag classes. The programming model that we adopt should let us do what we want without being burdonsome, and should provide a good foundation for more esoteric developments such as scaffolding and formbuilding.

